---
title: 二叉树遍历模板
tags:
    - 二叉树
date: 2021-09-20
---

二叉树相关题目思维难度不高，但是具体快速写出来就需要进行一些模板的记忆了

## 递归遍历

递归：

``` cpp 
class Solution { 
   public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        dfs(root, ans);
        return ans;
    }
    void dfs(TreeNode* cur, vector<int>& ans) {
        if (!cur) return;

        ans.push_back(cur->val);
        traversal(cur->left, ans);
        traversal(cur->right, ans); // 这三项交换顺序就是不同的前中后遍历
    }
};
```

## [lc：二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)  （中左右）

迭代：（stack）

``` cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (!root) return ans;

        stack<TreeNode*> st;
        st.push(root);
        
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            
            ans.push_back(node->val);
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return ans;
    }
};
```

## [lc: 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) (左中右)

相比于 前序遍历和 后序遍历使用不同的栈迭代方式：

``` cpp 
class Solution {
   public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (!root) return ans;

        stack<TreeNode*> st;
        TreeNode* cur = root;

        while (cur || !st.empty()) {
            if (cur) {
                st.push(cur);
                cur = cur->left;         // 左侧全部放入
            } else {
                cur = st.top(); st.pop();
                ans.push_back(cur->val); // ans 放入
                cur = cur->right;        // 向右侧节点偏移
            }
        }
        return ans;
    }
};
```


## [lc: 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) （左右中）

迭代：

``` cpp 
class Solution {
  public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (!root) return result;

        stack<TreeNode*> st;
        st.push(root);

        while (!st.empty()) {
            TreeNode* node = st.top(); st.pop();
            
            ans.push_back(node->val);
            if (node->left) st.push(node->left);    // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right);  // 空节点不入栈
        }
        reverse(ans.begin(), ans.end());      // 将结果反转之后就是左右中的顺序了
        return ans;
    }
};
```

## [lc: 二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

队列：

``` cpp
class Solution {
   public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);

        while (!que.empty()) {
            int size = que.size();
            vector<int> item;

            for (int i = 0; i < size; i++) {
                auto node = que.front(); 
                que.pop();

                item.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            ans.push_back(item);
        } 
        return ans;
    }
};
```