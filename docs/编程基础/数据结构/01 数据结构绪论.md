---
title: 第一章：数据结构绪论
---

***

## 计算

### 清华Oj使用

[共有四次作业](https://dsa.cs.tsinghua.edu.cn/oj/foyer.shtml)

computer science should be called computing science, for the same  
reason why surgery（手术） is not called knife science  
\- [E. Dijkstra](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra) 

### 绳索计算机及其算法

* 输入：直线l和上面任意一点A  
* 输出：经过A的一条垂线  

* 算法：
  + 古埃及人  

    红十字边框，共12段绳索，利用345直角三角形  
    将四和三点固定一个，同时拉直剩余的3+5  
    这时就出现了垂线  

### 尺规计算机及其算法

* 找一个线段的两个三等分点
* 算法：
  + 利用直角三角形等分性质。  

    直角边画出三等分点，做垂线在斜边的交点就是三等分点  

> 子程序->平行线作法

### 算法  

计算：借助工具，遵循一定规则，明确而机械的进行  
正确性，确定性，可行性，有穷性

* 有穷性  
  + 序列hailstone(n)

    奇数3n+1偶数n/2，1->1
    对于任意n，hailstone<正无穷？（未证明）

so 程序不等于算法  

### 好的算法，好的计算过程

正确，健壮，可读，**效率**

## 计算模型

### measure

DSA 度量(To measure is to know)  
时间成本：
规模相近时，都考虑最坏情况

特定问题+不同算法  
实验统计是最直接的算法，但不足够反映真实效率（算法和人一样各有所长）  
所以就构建了一些理想模型来measure算法  

### 对一般计算工具的简化和抽象

* 图灵机
  + tape默认为\#
  + alphabet字符的种类有限
  + read head 总是对准某一单元格，并可读取和修改其中的字符，可像左右移动
  + q, c; d, l\r, p(前两项为状态，后面为操作)  

  若当前状态为q，字符为c，则将字符改为d，向左右移动到邻格，状态为p，若状态为h，则停机  
  q，p处  <，>  
实例：
二进制数字翻转 (<, 1, 0, L, <)//左移，1-\>0  
用完读写头后，将其归位；  
其次今后使用算法时要规范接口，使用时先判断接口是否符合要求  

* RAM(random access machine)  

  寄存器

  + R[i]<-c  

    R[i]<-R[j]  
    R[R[i]]<-R[j]
    R[i]<-R[j]+-R[k]  
    goto if goto stop（用来写循环)

FLoor: 向下取整的除法
算法：统计R{0}减去R{1}在下溢前，所作减法的次数x

抽象后的简化，就可以用基本简单的操作来描述我们的算法，使我们独立于其他平台，能够客观的做出对算法效率的比较和评判  
运行时间<-算法需要执行基本操作的次数=T(n)  

## 大O记号

当问题规模足够大时，big O symbol

常系数可以省略，低次项可以省略（上界）
欧姆（）（下届）  sieta（）

* O(1)，常数复杂度  

    不含循环，调用，递归

* O(logn)  

    常底数无所谓,所以不标明  
    常数次幂  复杂度无限接近于常数  

* O($n^C$), 多项式复杂度

    $a^kn^k==O(n^k)$

* O(n)-O($n^2$)为编程习题主要复杂度
* 指数复杂度  

  难解O($2^n$)，  
  $n^c$=$O(2^n)$, 
  $n^1000$=O(2^n)$

很多问题多项式复杂度很难，指数复杂度算法显而易见  

* 例：  

  s包含n个正整数，$\sum_{k=1}^{n}S^n$=2m
  s是否有子集T，$\sum_{}{}T=m$  

  + 枚举所有子集计算和，$2^n$   

    NPC问题，不存在可以在多项式时间内解决的方法  

指数模型增长最快  

运用工具分析DSA，去粗存精  

## 复杂度分析主要方法

迭代，级数求和  
递归，递归跟踪+递归方程  
猜测加验证  

### 级数

* 算数级数  

通项公式最高项  

* 幂方级数：比幂次高出一阶  

$$T_4(n)=1^4+2^4+... +n^4=O(n^5)$$  

* 几何级数

    $a^0+a^1+a^2+...+a^n=\frac{a^n+^1-1}{a-1}=O(a^n)$  

    1+2+4--->$O(2^n)$

* 收敛级数

    几何分布->$O(1)$
    调和级数->$O(log_n)$  
    $1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n}$
    对数级数$O(nlog_n)$  
    $log1+log2+log3+...logn=logn!$

> 具体数学

``` cpp
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
        ..
    }
}
```

``` cpp
for(int i=0;i<n;i++){
    for(int j=0;j<i;j++/j+=2020){
        ..
    }
}
```

$O(n^2)$：  
计算过程为
三角形面积和正方形面积复杂度都为$O(n^2)$  

### 冒泡排序

``` cpp
void bubblesort(int A[];int n){
    for (bool sorted=false;sorted =!sorted;n--){
        for(int i=1;i<n;i++){//每一次把大的扔到最后面，全局有效标志翻转
            if(A[i-1]>A[i]){
                swap(A[i-1],A[i]);
                sorted=false;//清除全局有效标志
            }
        }
    }
}
```

经过k次扫描后，最大的k个元素就位(不变)  
单调，正确  

赤道周长的估算  
1天--25 x 4000 =$10^5$秒  
1世纪=$3$ x$10^4day$ = $3$ x $10^9sec$  

减少时间可以通过加强算法和更好的硬件

## 迭代与递归

递归的运行效率不一定高  
遇到大问题分而治之，不断减少问题规模

线性递归每个递归实例累计所需时间和为算法执行时间

递归跟踪：直观形象，适用于简单的递归模式
递推方程：适用于复杂的递归模式

### 数组倒置

``` cpp
void reverse(int *A,int low,int high){
    if(low==high){
            return A[low];
    }
    int mi = (low+high)>>1;
    return sum(a,low,mi)+sum(a,mi+1,high);
}
```

递归版
迭代版
迭代精简版

![截图1](/public\image\数据结构绪论下01.jpg)

``` cpp

```

### 数组求和

二分递归

``` cpp

```

通过递归跟踪到递归基

T(n)=O(1) x (2^0+2^1+2^2... +2^long_n)
=o(n)

//几何级数，总合和和末项同阶

底层递归实例共n个，所以复杂度为O(n); 

### Max2

从数组区间[lo, hi)中找出最大两个整数的比较次数，要求尽可能的少
hi并不是有效部分，但可以加进去考虑
![](/public\image\数据结构绪论下03.jpg); 

``` cpp
```

比较总数为(2n-3)

优化：

先构建两个指针，分别为第一个和第二个（先比较一次这两），
然后用第i个数据和她两作比较，如果大于x2则再与x1比较，这样只需要一次遍历便可找出来两个最大的值

![截图](/public\image\数据结构绪论下04.jpg)

```cpp

```

比较n-1次

### Max2: 二分递归

左侧最大次大，
右侧最大次大；

四个元素比两次就行

![截图](/public\image\数据结构绪论下05.jpg)

``` cpp

```

最好，最坏，
5n/3-2; 

