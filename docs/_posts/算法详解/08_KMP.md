---
title: KMP 算法
date: 2021-09-12
tags:
  - 算法详解
---

## 模板

因为理解一个算法没有什么实际意义，重要的还是你可以快速的写出来，实践性学科   
例如 KMP ，每个人都知道算法原理，但有几个人可以快速写出来正确的呢？，那你写不出来说什么也没用了

纯纯模板题罢了

``` cpp
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
int ne[N];
char s[M], p[N];

int main() {
    cin >> n >> p + 1 >> m >> s + 1;
    // 求 next 数组
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j++;
        ne[i] = j;
    }
    // 根据 next 数组的值进行查找优化
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j++;
        if (j == n) {
            printf("%d ", i - n);
            j = ne[j];
        }
    }

    return 0;
}
```


## KMP 算法：

一共由三十多种算法可以用来查找子字符串的问题，$kmp$ 算法保证了最坏情况也能在线性时间完成字符串的查找

在每次比对之前参与过比对的字符，在之后的比对中还会大量出现

所以主字符串会有一部分已经比对的字符和待比对字符串相等，
所以**已经掌握前一部分的全部信息——————字符串前一部分的每个字符是什么，但是我们没有利用这个关系**

所以就想着在匹配时省略一部分字符，再开始新的匹配

## `next[]` 数组

**next[] 表的含义以及原理：**

$\qquad$ 首先，要了解两个概念："前缀"和"后缀"。 "前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。next 表选取最大值（保证位移量尽可能小）

【(Partial Match Table) PMT 部分匹配表 】: 中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度。

![前缀后缀示例表](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406155519.png)

$\qquad$解释清楚这个表是什么之后，我们再来看如何使用这个表来加速字符串的查找，以及这样用的道理是什么。

$\qquad$要在主字符串 `"ababababca"` 中查找模式字符串 `"abababca"`。如果在 j 处字符不匹配，那么由于前边所说的模式字符串 `PMT` 的性质，主字符串中 `i` 指针之前的 `PMT[j −1]` 位就一定与模式字符串的第 `0` 位至第 `PMT[j −1]` 位是相同的。这是因为主字符串在 `i` 位失配，也就意味着主字符串从 `i−j` 到 `i` 这一段是与模式字符串的 `0` 到 `j` 这一段是完全相同的。

而我们上面也解释了，模式字符串从 0 到 j−1 , 在这个例子中就是”ababab”, 其前缀集合与后缀集合的交集的最长元素为”abab”,  长度为 4。所以就可以断言，主字符串中 i 指针之前的 4 位一定与模式字符串的第 0 位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。

**这样一来，我们就可以将前缀的这些字符段的比较省略掉。具体的做法是，保持 i 指针不动，然后将 j 指针指向模式字符串的 PMT[j −1] 位即可。**

简言之，以图中的例子来说，在 i 处失配，那么主字符串和模式字符串的前边 6 位就是相同的。又因为模式字符串的前 6 位，它的前 4 位前缀和后 4 位后缀是相同的，所以我们推知主字符串 i 之前的 4 位和模式字符串开头的 4 位是相同的。就是图中的灰色部分。那这部分就不用再比较了。

![20200406103358](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406103358.png)

$\qquad$有了上面的思路，我们就可以使用 PMT 加速字符串的查找了。**我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值**, 所以为了编程的方便，我们不直接使用 PMT 数组，而是将 PMT 数组向右偏移一位。我们把新得到的这个数组称为 next 数组。下面给出根据 next 数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把 PMT 进行向右偏移时，第 0 位的值，我们将其设成了-1, 这只是为了编程的方便，在如何构造中讨论。在例子中，next 数组如下表所示。

![20200406102609](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406102609.png)

```cpp
int KMP(char * t, char * p) {
	int i = 0;    //文本串指针
	int j = 0;    //模式串指针
	while (i < strlen(t) && j < strlen(p)){
		if (j == -1 || t[i] == p[j]) {
			i++;
           	j++;
		}
	 	else 
           	j = next[j]; //不修改变量 i, 模式串右移；
    }
    if (j == strlen(p))
       return i - j;
    else 
       return -1;
}
```

> 设置哨兵在算法中是常用方法，可以使算法易于理解并且方便使用

## KMP 构造 `next[]`

![4796975714855FA7132D3C32750E1BE1](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/4796975714855FA7132D3C32750E1BE1.jpg)

将可能出现 `P[0, t) == P[j - t, j)` 中所有的 t 值收集为一个集合，那么只有集合中的 t 才可以代替不匹配位置，继续进行比对操作

$\qquad$ 理解 -1: 想象一个 -1 放在左侧哨兵位置：等效于一个与所有字符都通配的字符，当模式串第一项也不能与主串匹配时，就跳转到通配符，通配符会进入 if 判断句，然后 ++i, ++j, 就等同于跳过了一个与首字符不匹配的字符

$\qquad$知道如何使用 `next[]` 后，快速构建 `next` 数组，是 KMP 算法的精髓所在，核心思想是 **“P 自己与自己做匹配”**。

`next[]`的定义为最大自匹配的真前缀和真后缀的长度  
故`next[j + 1] <= next[j] + 1`, 数值上任何一项相比于前一项至多增长一个单位

特别的，当且仅当 `P[j]==P[next[j]]` 时取等号  
当继任者与`P[j]`不相等时：
![7DFEEFBBCD7C58E87184BD118ECB6F0D](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/7DFEEFBBCD7C58E87184BD118ECB6F0D.jpg)

采用递推的方式来求解不匹配对应值：
**直到遇到当前不匹配字符与一部分前缀的末字符相等的替代者**, 就在前缀长度对应的`next[j]`上加一作为自己的`next[j]`的值

当不匹配字符和模式串第一个单字符还不匹配时，就用哨兵作为通配符和不匹配字符进行匹配，将这个值对应的 next 置为 0:`next[j + 1] = -1 + 1 == 0`, 等同于跳过这个值。

## `next[]` 构造实例：
1. `next[1]` 对应的首字符无前缀，所以与通配符-1 进行比较，进入 if 判断得到 `next[1]==0`,（这里发现第一个字符用的是 next[1] 的值，next[0] 为假想的哨兵）

2. 第二项字符 (j==1) 前缀只有 a 字符，与当前字符 b 不匹配，往前寻找执行 j=next[1]==0, 第 0 项与第一项还不匹配，寻求到 next[0] 通配符-1, -1+1=0, 将 next[2] 对应的值变为 0

![20200406160911](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406160911.png)

3. 第三项 (j==2) 开始的原因是通配符匹配了 b, 所以用首字符 a 来匹配第三项，发现匹配，在 next[2] 上累加 1 得到 next[3]=1

![20200406161140](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406161140.png)

4. (j==3) 发现相同，继续累加 1

![20200406161258](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406161258.png)

5. (j==4) 发现相同，继续累加 1
6. (j==5) 发现相同，继续累加 1

![20200406161226](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406161226.png)

7. 直到第 7 项时 (j==6) 发生对应字符不匹配，执行 6=next[6], 由第一步的规律得到 next[6] 为前六个字符的最大自匹配的串长，为 4, 现在就是 j = 4, 再将 c 与模式串的 [4] 进行比对，发现仍然不匹配，执行 j=next[4]==2, 将模式串的 [2] 与 c 字符相比仍然不匹配，执行 j=next[2]==0, 首字母比对仍然不同，寻求到通配符-1, `-1+1==0`, 进入 if, next[7] 置为 0, 继续考察下一项

![20200406161422](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406161422.png)

8. ……

代码实现：

```cpp
int * buildNext(char * p){
    int * next = new int [m]
	next[0] = -1;          //-1 为 next 表头
	int i = 0, j = -1;     //i 仍然是主字符串，j 为模式串

	while (i < strlen(p)){ //执行模式串长度次
		if (j == -1 || p[i] == p[j]){
			++i; //发现可以匹配的字符，可以立即得到 next 表得下一项，累加一个单位
			++j;
			next[i] = j;
        }
		else
			j = next[j]; //不相等时，更新 next 表向，最坏情况直到 -1+1==0 结束
	}
}
```

KMP 在最坏的情况也不会超过 $O(n)$

发生不匹配时，读取模式串中不匹配字符对应的 `next[j]` 对应值，将模式串对应下标的字符与主串中不匹配字符对齐

等效于：模式串聪明的跳过了一部分不可能发生匹配的字符

## KMP-算法：再改进

例如：
 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |
 | --- | --- | --- | --- | --- | --- | --- | --- | --- |
 | 0   | 0   | 0   | 0   | 1   |
 | -1  | 0   | 1   | 2   | 3   |


遇到上面这种情况下的性能表现不佳，（执行过程比蛮力算法还慢一点）

所以将 next 表的设计优化如下：（碰到石头就不让相同的鸡蛋继续碰石头）

 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |
 | --- | --- | --- | --- | --- | --- | --- | --- | --- |
 | 0   | 0   | 0   | 0   | 1   |
 | -1  | 0   | 0   | 0   | 3   |

代码实现：

```cpp {8}
int * buildNext( char * P) {
    size_t m = strlen(P),j=0;
    int * N = new int[m];
    int t = N[0] = -1; //完成通配符的设置
    while ( m - 1 > j ){ //KMP 循环
        if ( 0 > t || P[j] == P[t] ){
            j++;t++;
            N[j] = P[j] != P[t] ? t : N[t];//若替换字符和之前的字符不相等，正常实现，若替换字符仍然和之前的一个字符相等
        }                                  //, 那么就用之前的 next 表值直接赋值与相等的 next 值
        else //失配
            t = N[t];
    }
    return N;
}
```

KMP 相比于蛮力算法的优化图：
![5E5E9C38BE7FBB602EC23FABE3619FCA](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/5E5E9C38BE7FBB602EC23FABE3619FCA.jpg)

**只有字符集种类非常小时，KMP 算法的优化才会优势明显**


参考资料：

- 邓俊辉 -- 数据结构
- Acwing yxc -- KMP
- 哔哩哔哩 代码随想录 KMP 算法原理