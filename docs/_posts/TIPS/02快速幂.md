---
title: 快速幂
date: 2021-10-10
tags: Tips
---


快速处理 $a^k \mod p$ 的算法，也叫做欧拉降幂，当 k 的数据量特别大的时候，将计算时的复杂度从 $O(n)$ 降为 $O(log_n)$

朴素写法：$O(k)$  

``` cpp
int qmi(int a, int k, int p) {
    int ans = 0;
    ans = ans * a % p;
}
```

反复平方法：$O(log_k)$

首先预处理：共 $log_k$ 个数据


$a^k \mod p$ 的结果
$a^{2^0} \mod p$ 的结果
$a^{2^1} \mod p$ 的结果
$a^{2^2} \mod p$ 的结果
$a^{2^3} \mod p$ 的结果
$a^{2^4} \mod p$ 的结果
$\cdots$$\cdots$$\cdots$$\cdots$$\cdots$
$a^{2^{log_k}} \mod p$ 的结果，每一个数字都是上面一个数字的平方模 $p$

考虑 
$$a^k = a^{2^{x1}} a^{2^{x2}}a^{2^{x3}}a^{2^{x4}} \\
        = a^{(2^{x1} + 2^{x2} + 2^{x3} + 2^{x4})} $$

所以目标就是将 $k$ 拆成 $(2^{x1} + 2^{x2} + 2^{x3} + 2^{x4})$ 若干个数字的和，也就是将 $k$ 化为二进制，把那些对应是 1 的位乘进来



``` cpp
// 计算 a 的 k 次方 模 p 
int qmi(int a, int k, int p) {
    int ans = 1;
    while (k != 0) {       // 求 k 的二进制表示
        if (k & 1 == 1) ans = (LL)ans * a % p;
        // k & 1 表示 k 的最后一位是不是 1 ，
        // 如果是 1， ans = ans * a % p; 
        k >>= 1;           // 去除最后一位
        a = (LL)a * a % p; 
        // 把 a 变成下一个。每个数字是上一个数的平方模 p 
    }
    return ans;
}
```

模板：

``` cpp 
int qmi(int a, int k, int p) {
    int ans = 1;
    while (k != 0) {
        if (k & 1 == 1) ans = (LL)ans * a % p;
        k >>= 1;
        a = (LL)a * a % p; 
    }
    return ans;
}
```

lc50：`pow(x, n)`


``` cpp 
class Solution {
public:
    double myPow(double x, int n) {
        typedef long long LL;
        bool isMinus = (n < 0);

        double ans = 1;
        for (LL k = abs(LL(n)); k; k >>= 1) {
            if (k & 1) ans *= x;
            x *= x;
        }

        if (isMinus) ans = 1 / ans;
        return ans;
    }
};
```