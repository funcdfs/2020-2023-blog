---
title: 二叉树遍历模板
tags:
    - 二叉树
date: 2021-09-20
---

二叉树相关题目思维难度不高，但是具体快速写出来就需要进行一些模板的记忆了

## 递归遍历

递归：

``` cpp 
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        traversal(root, ans);
        return ans;
    }
    void traversal(TreeNode* cur, vector<int>& ans) {
        if (!cur) return;
        ans.push_back(cur->val);
        traversal(cur->left, ans);
        traversal(cur->right, ans); // 这里交换顺序即可
    }
};
```

## 前序遍历 （中左右）

https://leetcode-cn.com/problems/binary-tree-preorder-traversal/

迭代：（stack）

``` cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (!root) return ans;

        stack<TreeNode*> st;
        st.push(root);
        
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            
            ans.push_back(node->val);
            if (node->right) st.push(node->right);
            if (node->left) st.push(node->left);
        }
        return ans;
    }
};
```


## 中序遍历 (左中右)



迭代：

``` cpp 
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (!root) return ans;

        stack<TreeNode*> st;
        TreeNode* cur = root;

        while (cur || !st.empty()) {
            if (cur) {
                st.push(cur);
                cur = cur->left; // 左侧全部放入
            } else {
                cur = st.top(); st.pop();
                ans.push_back(cur->val); // ans 放入
                cur = cur->right; // 向右侧节点偏移
            }
        }
        return ans;
    }
};
```


## 后序遍历 （左右中：reverse）

迭代：

``` cpp 
class Solution {
  public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        if (!root) return result;

        stack<TreeNode*> st;
        st.push(root);

        while (!st.empty()) {
            TreeNode* node = st.top(); st.pop();
            
            ans.push_back(node->val);
            if (node->left) st.push(node->left);    // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right);  // 空节点不入栈
        }
        reverse(ans.begin(), ans.end());      // 将结果反转之后就是左右中的顺序了
        return ans;
    }
};
```

## 层次遍历 


队列：

``` cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        
        while (!que.empty()) {
            int size = que.size();
            vector<int> item;

            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front(); que.pop();

                item.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(item);
        }
        return ans;
    }
};
```